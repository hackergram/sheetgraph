<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">
        .node {
             font-family: Arial, Helvetica, sans-serif;
             font-size:10;
        }

        .link { stroke: #999; stroke-opacity: .6; stroke-width: 1px; }
    </style>
</head>
<body>
<svg width="2000" height="1000""></svg>

<script src="https://d3js.org/d3.v4.min.js" type="text/javascript"></script>
<script src="https://d3js.org/d3-selection-multi.v1.js"></script>

<script type="text/javascript">
    var colors = d3.scaleOrdinal(d3.schemeCategory10);

    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height"),
        node,
        link;

    svg.append('defs').append('marker')
        .attrs({'id':'arrowhead',
            'viewBox':'-0 -5 10 10',
            'refX':13,
            'refY':0,
            'orient':'auto',
            'markerWidth':13,
            'markerHeight':13,
            'xoverflow':'visible'})
        .append('svg:path')
        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
        .attr('fill', '#999')
        .style('stroke','none');

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) {return d.id;}).distance(80).strength(2))
        .force("charge", d3.forceManyBody())
        .force("x", d3.forceX())
        .force("y", d3.forceY())
        .force('collision', d3.forceCollide().radius(function(d) {
            return 50
          }))
        .force("center", d3.forceCenter(width / 2, height / 2));

  //  d3.json("graph.json", function (error, graph) {
  d3.json("http://192.168.56.101:5000/getGraphData", function(error, graph) {
        if (error) throw error;
        update(graph.links, graph.nodes);
    })

    function update(links, nodes) {
        link = svg.selectAll(".link")
            .data(links)
            .enter()
            .append("line")
            .attr("class", "link")
            .attr('marker-end','url(#arrowhead)')

        link.append("title")
            .text(function (d) {return d.weight;});

        edgepaths = svg.selectAll(".edgepath")
            .data(links)
            .enter()
            .append('path')
            .attrs({
                'class': 'edgepath',
                'fill-opacity': 0,
                'stroke-opacity': 0,
                'id': function (d, i) {return 'edgepath' + i}
            })
            .style("pointer-events", "none");

        edgelabels = svg.selectAll(".edgelabel")
            .data(links)
            .enter()
            .append('text')
            .style("pointer-events", "none")
            .attrs({
                'class': 'edgelabel',
                'id': function (d, i) {return 'edgelabel' + i},
                'font-size': 10
                //'fill': '#bbb'
            });

        edgelabels.append('textPath')
            .attr('xlink:href', function (d, i) {return '#edgepath' + i})
            .style("text-anchor", "middle")
            .style("pointer-events", "none")
            .attr("startOffset", "50%")
            .text(function (d) {return d.weight});

        node = svg.selectAll(".node")
            .data(nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended)
            );

        node.append("circle")
            .attr("r", 5)
            .style("fill", function (d, i) {return colors(i);})

        node.append("title")
            .text(function (d) {return d.id;});

        node.append("text")
            .attr("dy", -3)
            .text(function (d) {return d.id+":"+d.group;});

        simulation
            .nodes(nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(links);
    }

    function ticked() {
        link
            .attr("x1", function (d) {return d.source.x;})
            .attr("y1", function (d) {return d.source.y;})
            .attr("x2", function (d) {return d.target.x;})
            .attr("y2", function (d) {return d.target.y;});

        node
            .attr("transform", function (d) {return "translate(" + d.x + ", " + d.y + ")";})
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

        edgepaths.attr('d', function (d) {
            return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
        });

        edgelabels.attr('transform', function (d) {
            if (d.target.x < d.source.x) {
                var bbox = this.getBBox();

                rx = bbox.x + bbox.width / 2;
                ry = bbox.y + bbox.height / 2;
                return 'rotate(180 ' + rx + ' ' + ry + ')';
            }
            else {
                return 'rotate(0)';
            }
        });
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart()
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
        //console.log(d3.event.x, d3.event.y)
        d.fx = d3.event.x;
        d.fy = d3.event.y;

    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = d3.event.x;
        d.fy = d3.event.y;
        if (d.fx>width){
          d.fx=width-100
        }
        if(d.fy>height){
          d.fy=height-100
        }
        if (d.fx<0){
          d.fx=100
        }
        if(d.fy<0){
          d.fy=100
        }
    }

</script>
<script type="text/javascript">

		var edgeSize = 200;
		var timer = null;

		window.addEventListener( "mousemove", handleMousemove, false );

		drawGridLines();

		// --------------------------------------------------------------------------- //
		// --------------------------------------------------------------------------- //

		// I adjust the window scrolling in response to the given mousemove event.
		function handleMousemove( event ) {

			// NOTE: Much of the information here, with regard to document dimensions,
			// viewport dimensions, and window scrolling is derived from JavaScript.info.
			// I am consuming it here primarily as NOTE TO SELF.
			// --
			// Read More: https://javascript.info/size-and-scroll-window
			// --
			// CAUTION: The viewport and document dimensions can all be CACHED and then
			// recalculated on window-resize events (for the most part). I am keeping it
			// all here in the mousemove event handler to remove as many of the moving
			// parts as possible and keep the demo as simple as possible.

			// Get the viewport-relative coordinates of the mousemove event.
			var viewportX = event.clientX;
			var viewportY = event.clientY;

			// Get the viewport dimensions.
			var viewportWidth = document.documentElement.clientWidth;
			var viewportHeight = document.documentElement.clientHeight;

			// Next, we need to determine if the mouse is within the "edge" of the
			// viewport, which may require scrolling the window. To do this, we need to
			// calculate the boundaries of the edge in the viewport (these coordinates
			// are relative to the viewport grid system).
			var edgeTop = edgeSize;
			var edgeLeft = edgeSize;
			var edgeBottom = ( viewportHeight - edgeSize );
			var edgeRight = ( viewportWidth - edgeSize );

			var isInLeftEdge = ( viewportX < edgeLeft );
			var isInRightEdge = ( viewportX > edgeRight );
			var isInTopEdge = ( viewportY < edgeTop );
			var isInBottomEdge = ( viewportY > edgeBottom );

			// If the mouse is not in the viewport edge, there's no need to calculate
			// anything else.
			if ( ! ( isInLeftEdge || isInRightEdge || isInTopEdge || isInBottomEdge ) ) {

				clearTimeout( timer );
				return;

			}

			// If we made it this far, the user's mouse is located within the edge of the
			// viewport. As such, we need to check to see if scrolling needs to be done.

			// Get the document dimensions.
			// --
			// NOTE: The various property reads here are for cross-browser compatibility
			// as outlined in the JavaScript.info site (link provided above).
			var documentWidth = Math.max(
				document.body.scrollWidth,
				document.body.offsetWidth,
				document.body.clientWidth,
				document.documentElement.scrollWidth,
				document.documentElement.offsetWidth,
				document.documentElement.clientWidth
			);
			var documentHeight = Math.max(
				document.body.scrollHeight,
				document.body.offsetHeight,
				document.body.clientHeight,
				document.documentElement.scrollHeight,
				document.documentElement.offsetHeight,
				document.documentElement.clientHeight
			);

			// Calculate the maximum scroll offset in each direction. Since you can only
			// scroll the overflow portion of the document, the maximum represents the
			// length of the document that is NOT in the viewport.
			var maxScrollX = ( documentWidth - viewportWidth );
			var maxScrollY = ( documentHeight - viewportHeight );

			// As we examine the mousemove event, we want to adjust the window scroll in
			// immediate response to the event; but, we also want to continue adjusting
			// the window scroll if the user rests their mouse in the edge boundary. To
			// do this, we'll invoke the adjustment logic immediately. Then, we'll setup
			// a timer that continues to invoke the adjustment logic while the window can
			// still be scrolled in a particular direction.
			// --
			// NOTE: There are probably better ways to handle the ongoing animation
			// check. But, the point of this demo is really about the math logic, not so
			// much about the interval logic.
			(function checkForWindowScroll() {

				clearTimeout( timer );

				if ( adjustWindowScroll() ) {

					timer = setTimeout( checkForWindowScroll, 30 );

				}

			})();

			// Adjust the window scroll based on the user's mouse position. Returns True
			// or False depending on whether or not the window scroll was changed.
			function adjustWindowScroll() {

				// Get the current scroll position of the document.
				var currentScrollX = window.pageXOffset;
				var currentScrollY = window.pageYOffset;

				// Determine if the window can be scrolled in any particular direction.
				var canScrollUp = ( currentScrollY > 0 );
				var canScrollDown = ( currentScrollY < maxScrollY );
				var canScrollLeft = ( currentScrollX > 0 );
				var canScrollRight = ( currentScrollX < maxScrollX );

				// Since we can potentially scroll in two directions at the same time,
				// let's keep track of the next scroll, starting with the current scroll.
				// Each of these values can then be adjusted independently in the logic
				// below.
				var nextScrollX = currentScrollX;
				var nextScrollY = currentScrollY;

				// As we examine the mouse position within the edge, we want to make the
				// incremental scroll changes more "intense" the closer that the user
				// gets the viewport edge. As such, we'll calculate the percentage that
				// the user has made it "through the edge" when calculating the delta.
				// Then, that use that percentage to back-off from the "max" step value.
				var maxStep = 50;

				// Should we scroll left?
				if ( isInLeftEdge && canScrollLeft ) {

					var intensity = ( ( edgeLeft - viewportX ) / edgeSize );

					nextScrollX = ( nextScrollX - ( maxStep * intensity ) );

				// Should we scroll right?
				} else if ( isInRightEdge && canScrollRight ) {

					var intensity = ( ( viewportX - edgeRight ) / edgeSize );

					nextScrollX = ( nextScrollX + ( maxStep * intensity ) );

				}

				// Should we scroll up?
				if ( isInTopEdge && canScrollUp ) {

					var intensity = ( ( edgeTop - viewportY ) / edgeSize );

					nextScrollY = ( nextScrollY - ( maxStep * intensity ) );

				// Should we scroll down?
				} else if ( isInBottomEdge && canScrollDown ) {

					var intensity = ( ( viewportY - edgeBottom ) / edgeSize );

					nextScrollY = ( nextScrollY + ( maxStep * intensity ) );

				}

				// Sanitize invalid maximums. An invalid scroll offset won't break the
				// subsequent .scrollTo() call; however, it will make it harder to
				// determine if the .scrollTo() method should have been called in the
				// first place.
				nextScrollX = Math.max( 0, Math.min( maxScrollX, nextScrollX ) );
				nextScrollY = Math.max( 0, Math.min( maxScrollY, nextScrollY ) );

				if (
					( nextScrollX !== currentScrollX ) ||
					( nextScrollY !== currentScrollY )
					) {

					window.scrollTo( nextScrollX, nextScrollY );
					return( true );

				} else {

					return( false );

				}

			}

		}


		// I draw the grid and edge lines in the document so that it is clear where
		// scrolling will be initiated and with what intensity it is taking place.
		function drawGridLines() {

			var increment = 100;
			var incrementCount = 100;
			var maxDimension = ( increment * incrementCount );

			// Draw the boxes that make up the grid.
			for ( var x = 0 ; x < incrementCount ; x++ ) {
				for ( var y = 0 ; y < incrementCount ; y++ ) {

					var xOffset = ( x * increment );
					var yOffset = ( y * increment );

					var box = document.createElement( "span" );
					box.style.position = "absolute";
					box.style.top = ( yOffset + "px" );
					box.style.left = ( xOffset + "px" );
					box.style.height = ( increment + "px" );
					box.style.width = ( increment + "px" );
					box.style.border = "1px solid #CCCCCC";
					box.style.font = "11px sans-serif";
					box.style.color = "#999999" ;
					box.style.boxSizing = "border-box";
					box.style.padding = "5px 5px 5px 5px";
					box.innerText = ( xOffset + ", " + yOffset );
					document.body.appendChild( box );

				}
			}

			// Draw the edges that delineate the scrolling zone.
			var edge = document.createElement( "span" );
			edge.style.position = "fixed";
			edge.style.top = ( edgeSize + "px" );
			edge.style.bottom = ( edgeSize + "px" );
			edge.style.left = ( edgeSize + "px" );
			edge.style.right = ( edgeSize + "px" );
			edge.style.border = "2px solid #CC0000";
			edge.style.borderRadius = "5px 5px 5px 5px";
			document.body.appendChild( edge );

			// Add mouse-guard so that nothing is selectable.
			var guard = document.createElement( "div" );
			guard.style.position = "fixed";
			guard.style.top = "0px";
			guard.style.bottom = "0px";
			guard.style.left = "0px";
			guard.style.right = "0px";
			document.body.appendChild( guard );

		}

	</script>
</body>
</html>
